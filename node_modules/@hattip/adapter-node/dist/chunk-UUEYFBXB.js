// src/response.ts
import { Readable } from "stream";
var deno = typeof Deno !== "undefined";
if (deno) {
  const oldSet = Headers.prototype.set;
  Headers.prototype.set = function set(key, value) {
    if (Array.isArray(value)) {
      this.delete(key);
      value.forEach((v) => this.append(key, v));
    } else {
      oldSet.call(this, key, value);
    }
  };
}
async function sendResponse(fetchResponse, nodeResponse) {
  const { body: fetchBody } = fetchResponse;
  let body = null;
  if (!deno && fetchBody instanceof Readable) {
    body = fetchBody;
  } else if (fetchBody instanceof ReadableStream) {
    if (!deno && Readable.fromWeb) {
      body = Readable.fromWeb(fetchBody);
    } else {
      const reader = fetchBody.getReader();
      body = new Readable({
        async read() {
          const { done, value } = await reader.read();
          this.push(done ? null : value);
        }
      });
    }
  } else if (fetchBody) {
    body = Readable.from(fetchBody);
  }
  nodeResponse.statusCode = fetchResponse.status;
  if (fetchResponse.statusText) {
    nodeResponse.statusMessage = fetchResponse.statusText;
  }
  const uniqueHeaderNames = new Set(fetchResponse.headers.keys());
  for (const key of uniqueHeaderNames) {
    if (key === "set-cookie") {
      const setCookie = fetchResponse.headers.getSetCookie();
      if (nodeResponse.appendHeader) {
        for (const cookie of setCookie) {
          nodeResponse.appendHeader("set-cookie", cookie);
        }
      } else {
        nodeResponse.setHeader("set-cookie", setCookie);
      }
    } else {
      nodeResponse.setHeader(key, fetchResponse.headers.get(key));
    }
  }
  if (body) {
    body.pipe(nodeResponse);
    await new Promise((resolve, reject) => {
      body.on("error", reject);
      nodeResponse.on("finish", resolve);
      nodeResponse.on("error", reject);
    });
  } else {
    nodeResponse.setHeader("content-length", "0");
    nodeResponse.end();
  }
}

export {
  sendResponse
};
