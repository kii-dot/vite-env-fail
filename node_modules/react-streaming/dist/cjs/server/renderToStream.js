"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.disable = exports.renderToStream = void 0;
const react_1 = __importDefault(require("react"));
const server_1 = __importStar(require("react-dom/server"));
const useSuspenseData_1 = require("./useAsync/useSuspenseData");
const useStream_1 = require("./useStream");
const createPipeWrapper_1 = require("./renderToStream/createPipeWrapper");
const createReadableWrapper_1 = require("./renderToStream/createReadableWrapper");
const resolveSeoStrategy_1 = require("./renderToStream/resolveSeoStrategy");
const utils_1 = require("./utils");
const loadNodeStreamModule_1 = require("./renderToStream/loadNodeStreamModule");
const import_1 = __importDefault(require("@brillout/import"));
const debug = (0, utils_1.createDebugger)('react-streaming:flow');
assertReact();
const globalConfig = (globalThis.__react_streaming = globalThis
    .__react_streaming || {
    disable: false
});
function disable() {
    globalConfig.disable = true;
}
exports.disable = disable;
async function renderToStream(element, options = {}) {
    var _a, _b;
    element = react_1.default.createElement(useSuspenseData_1.SuspenseData, null, element);
    let injectToStream = (chunk) => buffer.push(chunk);
    const buffer = [];
    element = react_1.default.createElement(useStream_1.StreamProvider, {
        value: {
            injectToStream: (chunk) => {
                injectToStream(chunk);
            }
        }
    }, element);
    const disable = globalConfig.disable || ((_a = options.disable) !== null && _a !== void 0 ? _a : (0, resolveSeoStrategy_1.resolveSeoStrategy)(options).disableStream);
    const webStream = (_b = options.webStream) !== null && _b !== void 0 ? _b : !(await (0, loadNodeStreamModule_1.nodeStreamModuleIsAvailable)());
    debug(`disable === ${disable} && webStream === ${webStream}`);
    let result;
    const resultPartial = { disabled: disable };
    if (!webStream) {
        result = Object.assign(Object.assign({}, resultPartial), (await renderToNodeStream(element, disable, options)));
    }
    else {
        result = Object.assign(Object.assign({}, resultPartial), (await renderToWebStream(element, disable, options)));
    }
    injectToStream = result.injectToStream;
    buffer.forEach((chunk) => injectToStream(chunk));
    buffer.length = 0;
    debug('promise `await renderToStream()` resolved');
    return result;
}
exports.renderToStream = renderToStream;
async function renderToNodeStream(element, disable, options) {
    var _a;
    debug('creating Node.js Stream Pipe');
    let onAllReady;
    const allReady = new Promise((r) => {
        onAllReady = () => r();
    });
    let onShellReady;
    const shellReady = new Promise((r) => {
        onShellReady = () => r();
    });
    let didError = false;
    let firstErr = null;
    let reactBug = null;
    const onError = (err) => {
        debug('[react] onError() / onShellError()');
        didError = true;
        firstErr !== null && firstErr !== void 0 ? firstErr : (firstErr = err);
        onShellReady();
        afterReactBugCatch(() => {
            var _a;
            // Is not a React internal error (i.e. a React bug)
            if (err !== reactBug) {
                (_a = options.onBoundaryError) === null || _a === void 0 ? void 0 : _a.call(options, err);
            }
        });
    };
    const renderToPipeableStream = (_a = options.renderToPipeableStream) !== null && _a !== void 0 ? _a : 
    // We don't directly use import() because it shouldn't be bundled for Cloudflare Workers: the module react-dom/server.node contains a require('stream') which fails on Cloudflare Workers
    (await (0, import_1.default)('react-dom/server.node')).renderToPipeableStream;
    assertReactImport(renderToPipeableStream, 'renderToPipeableStream');
    const { pipe: pipeOriginal } = renderToPipeableStream(element, {
        onShellReady() {
            debug('[react] onShellReady()');
            onShellReady();
        },
        onAllReady() {
            debug('[react] onAllReady()');
            onShellReady();
            onAllReady();
        },
        onShellError: onError,
        onError
    });
    let promiseResolved = false;
    const { pipeForUser, injectToStream, streamEnd } = await (0, createPipeWrapper_1.createPipeWrapper)(pipeOriginal, {
        onReactBug(err) {
            debug('react bug');
            didError = true;
            firstErr !== null && firstErr !== void 0 ? firstErr : (firstErr = err);
            reactBug = err;
            // Only log if it wasn't used as rejection for `await renderToStream()`
            if (reactBug !== firstErr || promiseResolved) {
                console.error(reactBug);
            }
        }
    });
    await shellReady;
    if (didError)
        throw firstErr;
    if (disable)
        await allReady;
    if (didError)
        throw firstErr;
    promiseResolved = true;
    return {
        pipe: pipeForUser,
        readable: null,
        streamEnd: wrapStreamEnd(streamEnd, didError),
        injectToStream
    };
}
async function renderToWebStream(element, disable, options) {
    var _a;
    debug('creating Web Stream Pipe');
    let didError = false;
    let firstErr = null;
    let reactBug = null;
    const onError = (err) => {
        didError = true;
        firstErr = firstErr || err;
        afterReactBugCatch(() => {
            var _a;
            // Is not a React internal error (i.e. a React bug)
            if (err !== reactBug) {
                (_a = options.onBoundaryError) === null || _a === void 0 ? void 0 : _a.call(options, err);
            }
        });
    };
    const renderToReadableStream = (_a = options.renderToReadableStream) !== null && _a !== void 0 ? _a : 
    // We directly use import() because it needs to be bundled for Cloudflare Workers
    (await import('react-dom/server.browser')).renderToReadableStream;
    assertReactImport(renderToReadableStream, 'renderToReadableStream');
    const readableOriginal = await renderToReadableStream(element, { onError });
    const { allReady } = readableOriginal;
    let promiseResolved = false;
    // Upon React internal errors (i.e. React bugs), React rejects `allReady`.
    // React doesn't reject `allReady` upon boundary errors.
    allReady.catch((err) => {
        debug('react bug');
        didError = true;
        firstErr = firstErr || err;
        reactBug = err;
        // Only log if it wasn't used as rejection for `await renderToStream()`
        if (reactBug !== firstErr || promiseResolved) {
            console.error(reactBug);
        }
    });
    if (didError)
        throw firstErr;
    if (disable)
        await allReady;
    if (didError)
        throw firstErr;
    const { readableForUser, streamEnd, injectToStream } = (0, createReadableWrapper_1.createReadableWrapper)(readableOriginal);
    promiseResolved = true;
    return {
        readable: readableForUser,
        pipe: null,
        streamEnd: wrapStreamEnd(streamEnd, didError),
        injectToStream
    };
}
// Needed for the hacky solution to workaround https://github.com/facebook/react/issues/24536
function afterReactBugCatch(fn) {
    setTimeout(() => {
        fn();
    }, 0);
}
function wrapStreamEnd(streamEnd, didError) {
    return (streamEnd
        // Needed because of the `afterReactBugCatch()` hack above, otherwise `onBoundaryError` triggers after `streamEnd` resolved
        .then(() => new Promise((r) => setTimeout(r, 0)))
        .then(() => !didError));
}
// To debug wrong peer dependency loading:
//  - https://stackoverflow.com/questions/21056748/seriously-debugging-node-js-cannot-find-module-xyz-abcd
//  - https://stackoverflow.com/questions/59865584/how-to-invalidate-cached-require-resolve-results
function assertReact() {
    const versionMajor = parseInt(server_1.version.split('.')[0], 10);
    (0, utils_1.assertUsage)(versionMajor >= 18, `\`react-dom@${server_1.version}\` was loaded, but react-streaming only works with React version 18 or greater.`);
    (0, utils_1.assert)(typeof server_1.default.renderToPipeableStream === 'function' ||
        typeof server_1.default.renderToReadableStream === 'function');
}
function assertReactImport(fn, fnName) {
    (0, utils_1.assert)(typeof fn === 'function');
    (0, utils_1.assertUsage)(fn, `Couldn't import ${fnName}() from 'react-dom'`);
}
