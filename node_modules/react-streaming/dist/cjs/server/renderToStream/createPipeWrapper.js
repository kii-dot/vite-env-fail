"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPipeWrapper = void 0;
const utils_1 = require("../utils");
const createBuffer_1 = require("./createBuffer");
const loadNodeStreamModule_1 = require("./loadNodeStreamModule");
const debug = (0, utils_1.createDebugger)('react-streaming:createPipeWrapper');
async function createPipeWrapper(pipeFromReact, { onReactBug }) {
    const { Writable } = await (0, loadNodeStreamModule_1.loadNodeStreamModule)();
    const { pipeForUser, streamEnd } = createPipeForUser();
    const streamOperations = {
        operations: null
    };
    const { injectToStream, onBeforeWrite, onBeforeEnd } = (0, createBuffer_1.createBuffer)(streamOperations);
    return { pipeForUser, streamEnd, injectToStream };
    function createPipeForUser() {
        debug('createPipeForUser()');
        let onEnded;
        const streamEnd = new Promise((r) => {
            onEnded = () => r();
        });
        const pipeForUser = (writableFromUser) => {
            const writableForReact = new Writable({
                write(chunk, encoding, callback) {
                    debug('write');
                    onBeforeWrite(chunk);
                    if (!writableFromUser.destroyed) {
                        writableFromUser.write(chunk, encoding, callback);
                    }
                    else {
                        // Destroying twice is fine: https://github.com/brillout/react-streaming/pull/21#issuecomment-1554517163
                        writableForReact.destroy();
                    }
                },
                final(callback) {
                    debug('final');
                    onBeforeEnd();
                    writableFromUser.end();
                    onEnded();
                    callback();
                },
                destroy(err) {
                    debug(`destroy (\`!!err === ${!!err}\`)`);
                    // Upon React internal errors (i.e. React bugs), React destroys the stream.
                    if (err)
                        onReactBug(err);
                    writableFromUser.destroy(err !== null && err !== void 0 ? err : undefined);
                    onEnded();
                }
            });
            const flush = () => {
                if (typeof writableFromUser.flush === 'function') {
                    ;
                    writableFromUser.flush();
                    debug('stream flushed (Node.js Writable)');
                }
            };
            streamOperations.operations = {
                flush,
                writeChunk(chunk) {
                    writableFromUser.write(chunk);
                }
            };
            writableForReact.flush = flush;
            pipeFromReact(writableForReact);
        };
        return { pipeForUser, streamEnd };
    }
}
exports.createPipeWrapper = createPipeWrapper;
