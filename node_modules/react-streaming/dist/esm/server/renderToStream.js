export { renderToStream };
export { disable };
import React from 'react';
import ReactDOMServer, { version as reactDomVersion } from 'react-dom/server';
import { SuspenseData } from './useAsync/useSuspenseData';
import { StreamProvider } from './useStream';
import { createPipeWrapper } from './renderToStream/createPipeWrapper';
import { createReadableWrapper } from './renderToStream/createReadableWrapper';
import { resolveSeoStrategy } from './renderToStream/resolveSeoStrategy';
import { assert, assertUsage, createDebugger } from './utils';
import { nodeStreamModuleIsAvailable } from './renderToStream/loadNodeStreamModule';
import import_ from '@brillout/import';
const debug = createDebugger('react-streaming:flow');
assertReact();
const globalConfig = (globalThis.__react_streaming = globalThis
    .__react_streaming || {
    disable: false
});
function disable() {
    globalConfig.disable = true;
}
async function renderToStream(element, options = {}) {
    var _a, _b;
    element = React.createElement(SuspenseData, null, element);
    let injectToStream = (chunk) => buffer.push(chunk);
    const buffer = [];
    element = React.createElement(StreamProvider, {
        value: {
            injectToStream: (chunk) => {
                injectToStream(chunk);
            }
        }
    }, element);
    const disable = globalConfig.disable || ((_a = options.disable) !== null && _a !== void 0 ? _a : resolveSeoStrategy(options).disableStream);
    const webStream = (_b = options.webStream) !== null && _b !== void 0 ? _b : !(await nodeStreamModuleIsAvailable());
    debug(`disable === ${disable} && webStream === ${webStream}`);
    let result;
    const resultPartial = { disabled: disable };
    if (!webStream) {
        result = { ...resultPartial, ...(await renderToNodeStream(element, disable, options)) };
    }
    else {
        result = { ...resultPartial, ...(await renderToWebStream(element, disable, options)) };
    }
    injectToStream = result.injectToStream;
    buffer.forEach((chunk) => injectToStream(chunk));
    buffer.length = 0;
    debug('promise `await renderToStream()` resolved');
    return result;
}
async function renderToNodeStream(element, disable, options) {
    var _a;
    debug('creating Node.js Stream Pipe');
    let onAllReady;
    const allReady = new Promise((r) => {
        onAllReady = () => r();
    });
    let onShellReady;
    const shellReady = new Promise((r) => {
        onShellReady = () => r();
    });
    let didError = false;
    let firstErr = null;
    let reactBug = null;
    const onError = (err) => {
        debug('[react] onError() / onShellError()');
        didError = true;
        firstErr !== null && firstErr !== void 0 ? firstErr : (firstErr = err);
        onShellReady();
        afterReactBugCatch(() => {
            var _a;
            // Is not a React internal error (i.e. a React bug)
            if (err !== reactBug) {
                (_a = options.onBoundaryError) === null || _a === void 0 ? void 0 : _a.call(options, err);
            }
        });
    };
    const renderToPipeableStream = (_a = options.renderToPipeableStream) !== null && _a !== void 0 ? _a : 
    // We don't directly use import() because it shouldn't be bundled for Cloudflare Workers: the module react-dom/server.node contains a require('stream') which fails on Cloudflare Workers
    (await import_('react-dom/server.node')).renderToPipeableStream;
    assertReactImport(renderToPipeableStream, 'renderToPipeableStream');
    const { pipe: pipeOriginal } = renderToPipeableStream(element, {
        onShellReady() {
            debug('[react] onShellReady()');
            onShellReady();
        },
        onAllReady() {
            debug('[react] onAllReady()');
            onShellReady();
            onAllReady();
        },
        onShellError: onError,
        onError
    });
    let promiseResolved = false;
    const { pipeForUser, injectToStream, streamEnd } = await createPipeWrapper(pipeOriginal, {
        onReactBug(err) {
            debug('react bug');
            didError = true;
            firstErr !== null && firstErr !== void 0 ? firstErr : (firstErr = err);
            reactBug = err;
            // Only log if it wasn't used as rejection for `await renderToStream()`
            if (reactBug !== firstErr || promiseResolved) {
                console.error(reactBug);
            }
        }
    });
    await shellReady;
    if (didError)
        throw firstErr;
    if (disable)
        await allReady;
    if (didError)
        throw firstErr;
    promiseResolved = true;
    return {
        pipe: pipeForUser,
        readable: null,
        streamEnd: wrapStreamEnd(streamEnd, didError),
        injectToStream
    };
}
async function renderToWebStream(element, disable, options) {
    var _a;
    debug('creating Web Stream Pipe');
    let didError = false;
    let firstErr = null;
    let reactBug = null;
    const onError = (err) => {
        didError = true;
        firstErr = firstErr || err;
        afterReactBugCatch(() => {
            var _a;
            // Is not a React internal error (i.e. a React bug)
            if (err !== reactBug) {
                (_a = options.onBoundaryError) === null || _a === void 0 ? void 0 : _a.call(options, err);
            }
        });
    };
    const renderToReadableStream = (_a = options.renderToReadableStream) !== null && _a !== void 0 ? _a : 
    // We directly use import() because it needs to be bundled for Cloudflare Workers
    (await import('react-dom/server.browser')).renderToReadableStream;
    assertReactImport(renderToReadableStream, 'renderToReadableStream');
    const readableOriginal = await renderToReadableStream(element, { onError });
    const { allReady } = readableOriginal;
    let promiseResolved = false;
    // Upon React internal errors (i.e. React bugs), React rejects `allReady`.
    // React doesn't reject `allReady` upon boundary errors.
    allReady.catch((err) => {
        debug('react bug');
        didError = true;
        firstErr = firstErr || err;
        reactBug = err;
        // Only log if it wasn't used as rejection for `await renderToStream()`
        if (reactBug !== firstErr || promiseResolved) {
            console.error(reactBug);
        }
    });
    if (didError)
        throw firstErr;
    if (disable)
        await allReady;
    if (didError)
        throw firstErr;
    const { readableForUser, streamEnd, injectToStream } = createReadableWrapper(readableOriginal);
    promiseResolved = true;
    return {
        readable: readableForUser,
        pipe: null,
        streamEnd: wrapStreamEnd(streamEnd, didError),
        injectToStream
    };
}
// Needed for the hacky solution to workaround https://github.com/facebook/react/issues/24536
function afterReactBugCatch(fn) {
    setTimeout(() => {
        fn();
    }, 0);
}
function wrapStreamEnd(streamEnd, didError) {
    return (streamEnd
        // Needed because of the `afterReactBugCatch()` hack above, otherwise `onBoundaryError` triggers after `streamEnd` resolved
        .then(() => new Promise((r) => setTimeout(r, 0)))
        .then(() => !didError));
}
// To debug wrong peer dependency loading:
//  - https://stackoverflow.com/questions/21056748/seriously-debugging-node-js-cannot-find-module-xyz-abcd
//  - https://stackoverflow.com/questions/59865584/how-to-invalidate-cached-require-resolve-results
function assertReact() {
    const versionMajor = parseInt(reactDomVersion.split('.')[0], 10);
    assertUsage(versionMajor >= 18, `\`react-dom@${reactDomVersion}\` was loaded, but react-streaming only works with React version 18 or greater.`);
    assert(typeof ReactDOMServer.renderToPipeableStream === 'function' ||
        typeof ReactDOMServer.renderToReadableStream === 'function');
}
function assertReactImport(fn, fnName) {
    assert(typeof fn === 'function');
    assertUsage(fn, `Couldn't import ${fnName}() from 'react-dom'`);
}
