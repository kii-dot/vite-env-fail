"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineOptimizeDeps = void 0;
const findPageFiles_js_1 = require("../../shared/findPageFiles.js");
const utils_js_1 = require("../../utils.js");
const getVikeConfig_js_1 = require("../importUserCode/v1-design/getVikeConfig.js");
const getConfigValueSourcesNotOverriden_js_1 = require("../../shared/getConfigValueSourcesNotOverriden.js");
const buildConfig_js_1 = require("../buildConfig.js");
const virtualFileImportUserCode_js_1 = require("../../../shared/virtual-files/virtualFileImportUserCode.js");
async function determineOptimizeDeps(config, configVike, isDev) {
    const { pageConfigs } = await (0, getVikeConfig_js_1.getVikeConfig)(config, isDev);
    const { entries, include } = await getPageDeps(config, pageConfigs, isDev);
    {
        // This actually doesn't work: Vite's dep optimizer doesn't seem to be able to crawl virtual files.
        //  - Should we make it work? E.g. by creating a temporary file at node_modules/.vike/virtualFiles.js
        //  - Or should we remove it? And make sure getPageDeps() also works for aliased import paths
        //    - If we do, then we need to adjust include/entries (maybe by making include === entries -> will Vite complain?)
        const entriesVirtualFiles = getVirtualFiles(config, pageConfigs);
        entries.push(...entriesVirtualFiles);
    }
    include.push(...getExtensionsDeps(configVike));
    /* Other Vite plugins may populate optimizeDeps, e.g. Cypress: https://github.com/vikejs/vike/issues/386
    assert(config.optimizeDeps.entries === undefined)
    */
    config.optimizeDeps.include = [...include, ...normalizeInclude(config.optimizeDeps.include)];
    config.optimizeDeps.entries = [...entries, ...normalizeEntries(config.optimizeDeps.entries)];
    // console.log('config.optimizeDeps', { entries: config.optimizeDeps.entries, include: config.optimizeDeps.include })
}
exports.determineOptimizeDeps = determineOptimizeDeps;
async function getPageDeps(config, pageConfigs, isDev) {
    let entries = [];
    let include = [];
    // V1 design
    {
        pageConfigs.forEach((pageConfig) => {
            (0, getConfigValueSourcesNotOverriden_js_1.getConfigValueSourcesNotOverriden)(pageConfig).forEach((configValueSource) => {
                if (!configValueSource.valueIsImportedAtRuntime)
                    return;
                const { definedAt, configEnv } = configValueSource;
                if (!configEnv.client)
                    return;
                if (definedAt.filePathRelativeToUserRootDir !== null) {
                    const { filePathAbsoluteFilesystem } = definedAt;
                    (0, utils_js_1.assert)(filePathAbsoluteFilesystem);
                    // Surprisingly Vite expects entries to be absolute paths
                    entries.push(filePathAbsoluteFilesystem);
                }
                else {
                    // Adding definedAt.filePathAbsoluteFilesystem doesn't work for npm packages, I guess because of Vite's config.server.fs.allow
                    const { importPathAbsolute } = definedAt;
                    (0, utils_js_1.assert)(importPathAbsolute);
                    // We need to differentiate between npm package imports and path aliases.
                    // There are path aliases that cannot be distinguished from npm package names.
                    // We recommend users to use the '#' prefix convention for path aliases, see https://vike.dev/path-aliases#vite and assertResolveAlias()
                    if ((0, utils_js_1.isNpmPackageImport)(importPathAbsolute)) {
                        // isNpmPackageImport() returns false for a path alias like #root/renderer/onRenderClient
                        (0, utils_js_1.assert)(!importPathAbsolute.startsWith('#'));
                        include.push(importPathAbsolute);
                    }
                    else {
                        /* Path aliases, e.g.:
                         * ```js
                         * // /renderer/+config.js
                         * import onRenderClient from '#root/renderer/onRenderClient'
                         * ```
                         */
                        entries.push(importPathAbsolute);
                    }
                }
            });
        });
    }
    // V0.4 design
    {
        const pageFiles = await (0, findPageFiles_js_1.findPageFiles)(config, ['.page', '.page.client'], isDev);
        pageFiles.forEach((filePath) => {
            const entry = (0, utils_js_1.getFilePathAbsolute)(filePath, config);
            entries.push(entry);
        });
    }
    entries = (0, utils_js_1.unique)(entries);
    include = (0, utils_js_1.unique)(include);
    return { entries, include };
}
function getVirtualFiles(config, pageConfigs) {
    const { hasClientRouting, hasServerRouting, clientEntries } = (0, buildConfig_js_1.analyzeClientEntries)(pageConfigs, config);
    const entriesVirtualFiles = Object.values(clientEntries);
    if (hasClientRouting)
        entriesVirtualFiles.push(virtualFileImportUserCode_js_1.virtualFileIdImportUserCodeClientCR);
    if (hasServerRouting)
        entriesVirtualFiles.push(virtualFileImportUserCode_js_1.virtualFileIdImportUserCodeClientSR);
    return entriesVirtualFiles;
}
function getExtensionsDeps(configVike) {
    return [
        /* Doesn't work since `pageConfigsSrcDir` is a directory. We could make it work by using find-glob.
        ...configVike.extensions
          .map(({ pageConfigsSrcDir }) => pageConfigsSrcDir)
          .flat()
          .filter(isNotNullish),
        //*/
        ...configVike.extensions
            .map(({ pageConfigsDistFiles }) => pageConfigsDistFiles)
            .flat()
            .filter(utils_js_1.isNotNullish)
            .filter(({ importPath }) => !importPath.endsWith('.css'))
            .map(({ importPath }) => importPath)
    ];
}
function normalizeEntries(entries) {
    if (Array.isArray(entries))
        return entries;
    if (typeof entries === 'string')
        return [entries];
    if (entries === undefined)
        return [];
    (0, utils_js_1.assert)(false);
}
function normalizeInclude(include) {
    if (Array.isArray(include))
        return include;
    if (include === undefined)
        return [];
    (0, utils_js_1.assert)(false);
}
