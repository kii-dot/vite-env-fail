"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.crawlPlusFiles = void 0;
const utils_js_1 = require("../../../../utils.js");
const path_1 = __importDefault(require("path"));
const fast_glob_1 = __importDefault(require("fast-glob"));
const child_process_1 = require("child_process");
const util_1 = require("util");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const execA = (0, util_1.promisify)(child_process_1.exec);
const globalObject = (0, utils_js_1.getGlobalObject)('crawlPlusFiles.ts', {
    gitIsMissing: false
});
async function crawlPlusFiles(userRootDir, outDirAbsoluteFilesystem, isDev) {
    (0, utils_js_1.assertPosixPath)(userRootDir);
    (0, utils_js_1.assertPosixPath)(outDirAbsoluteFilesystem);
    let outDirRelativeFromUserRootDir = path_1.default.posix.relative(userRootDir, outDirAbsoluteFilesystem);
    if (outDirRelativeFromUserRootDir.startsWith('../')) {
        // config.outDir is outside of config.root => it's going to be ignored anyways
        outDirRelativeFromUserRootDir = null;
    }
    (0, utils_js_1.assert)(outDirRelativeFromUserRootDir === null || !outDirRelativeFromUserRootDir.startsWith('.'));
    const timeBefore = new Date().getTime();
    let files = [];
    const res = await gitLsFiles(userRootDir, outDirRelativeFromUserRootDir);
    if (res &&
        // Fallback to fast-glob for users that dynamically generate plus files. (Assuming all (generetad) plus files to be skipped because users usually included them in `.gitignore`.)
        res.length > 0) {
        files = res;
    }
    else {
        files = await fastGlob(userRootDir, outDirRelativeFromUserRootDir);
    }
    {
        const timeAfter = new Date().getTime();
        const timeSpent = timeAfter - timeBefore;
        if (isDev) {
            // We only warn in dev, because while building it's expected to take a long time as crawling is competing for resources with other tasks.
            // Although, in dev, it's also competing for resources e.g. with Vite's `optimizeDeps`.
            (0, utils_js_1.assertWarning)(timeSpent < 3 * 1000, `Crawling your ${picocolors_1.default.cyan('+')} files took an unexpected long time (${(0, utils_js_1.humanizeTime)(timeSpent)}). If you repeatedly get this warning, then consider creating a new issue on Vike's GitHub.`, {
                onlyOnce: 'slow-page-files-search'
            });
        }
    }
    const plusFiles = files.map((p) => {
        p = (0, utils_js_1.toPosixPath)(p);
        (0, utils_js_1.assert)(!p.startsWith(userRootDir));
        const filePathRelativeToUserRootDir = path_1.default.posix.join('/', p);
        const filePathAbsoluteFilesystem = path_1.default.posix.join(userRootDir, p);
        return {
            filePathRelativeToUserRootDir,
            filePathAbsoluteFilesystem
        };
    });
    return plusFiles;
}
exports.crawlPlusFiles = crawlPlusFiles;
// Same as fastGlob() but using `$ git ls-files`
async function gitLsFiles(userRootDir, outDirRelativeFromUserRootDir) {
    if (globalObject.gitIsMissing)
        return null;
    const ignoreAsPatterns = getIgnoreAsPatterns(outDirRelativeFromUserRootDir);
    const ignoreAsFilterFn = getIgnoreAsFilterFn(outDirRelativeFromUserRootDir);
    const cmd = [
        'git ls-files',
        ...utils_js_1.scriptFileExtensionList.map((ext) => `"**/+*.${ext}"`),
        ...ignoreAsPatterns.map((pattern) => `--exclude="${pattern}"`),
        // --others lists untracked files only (but using .gitignore because --exclude-standard)
        // --cached adds the tracked files to the output
        '--others --cached --exclude-standard'
    ].join(' ');
    let files;
    let filesDeleted;
    try {
        ;
        [files, filesDeleted] = await Promise.all([
            // Main command
            runCmd(cmd, userRootDir),
            // Get tracked by deleted files
            runCmd('git ls-files --deleted', userRootDir)
        ]);
    }
    catch (err) {
        if (await isGitMissing(userRootDir)) {
            globalObject.gitIsMissing = true;
            return null;
        }
        throw err;
    }
    files = files
        // We have to repeat the same exclusion logic here because the `git ls-files` option --exclude only applies to untracked files. (We use --exclude only to speed up the command.)
        .filter(ignoreAsFilterFn)
        .filter((file) => !filesDeleted.includes(file));
    return files;
}
// Same as gitLsFiles() but using fast-glob
async function fastGlob(userRootDir, outDirRelativeFromUserRootDir) {
    const files = await (0, fast_glob_1.default)(`**/+*.${utils_js_1.scriptFileExtensions}`, {
        ignore: getIgnoreAsPatterns(outDirRelativeFromUserRootDir),
        cwd: userRootDir,
        dot: false
    });
    return files;
}
// Same as getIgnoreFilter() but as glob pattern
function getIgnoreAsPatterns(outDirRelativeFromUserRootDir) {
    const ignoreAsPatterns = [
        '**/node_modules/**',
        // Allow:
        // ```
        // +Page.js
        // +Page.telefunc.js
        // ```
        '**/*.telefunc.*'
    ];
    if (outDirRelativeFromUserRootDir) {
        (0, utils_js_1.assert)(!outDirRelativeFromUserRootDir.startsWith('/'));
        ignoreAsPatterns.push(`${outDirRelativeFromUserRootDir}/**`);
    }
    return ignoreAsPatterns;
}
// Same as getIgnorePatterns() but for Array.filter()
function getIgnoreAsFilterFn(outDirRelativeFromUserRootDir) {
    (0, utils_js_1.assert)(outDirRelativeFromUserRootDir === null || !outDirRelativeFromUserRootDir.startsWith('/'));
    return (file) => !file.includes('node_modules/') &&
        !file.includes('.telefunc.') &&
        (outDirRelativeFromUserRootDir === null || !file.startsWith(`${outDirRelativeFromUserRootDir}/`));
}
// Whether Git is installed and whether userRootDir is inside a Git repository
async function isGitMissing(userRootDir) {
    let res;
    try {
        res = await execA('git rev-parse --is-inside-work-tree', { cwd: userRootDir });
    }
    catch {
        return true;
    }
    const { stdout, stderr } = res;
    (0, utils_js_1.assert)(stderr.toString().trim() === '');
    (0, utils_js_1.assert)(stdout.toString().trim() === 'true');
    return false;
}
async function runCmd(cmd, cwd) {
    const res = await execA(cmd, { cwd });
    (0, utils_js_1.assert)(res.stderr === '');
    return res.stdout.toString().split('\n').filter(Boolean);
}
