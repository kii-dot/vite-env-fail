"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => allPlugins
});
module.exports = __toCommonJS(src_exports);
var import_promises4 = __toESM(require("fs/promises"), 1);

// src/utils.ts
var import_vite = require("vite");
var import_path = __toESM(require("path"), 1);
function getRoot(config) {
  return (0, import_vite.normalizePath)(config.root || process.cwd());
}
function getOutput(config, suffix) {
  var _a, _b;
  return import_path.default.join(
    ((_a = config.vercel) == null ? void 0 : _a.outDir) ? "" : getRoot(config),
    ((_b = config.vercel) == null ? void 0 : _b.outDir) ?? ".vercel/output",
    suffix ?? ""
  );
}
function getPublic(config) {
  return import_path.default.join(getRoot(config), config.publicDir || "public");
}
function pathRelativeTo(filePath, config, rel) {
  const root = getRoot(config);
  return (0, import_vite.normalizePath)(
    import_path.default.relative((0, import_vite.normalizePath)(import_path.default.join(root, rel)), filePath)
  );
}

// src/config.ts
var import_path2 = __toESM(require("path"), 1);

// src/schemas/config/config.ts
var import_zod = require("zod");
var HasOrMissing = import_zod.z.array(
  import_zod.z.union([
    import_zod.z.object({
      type: import_zod.z.literal("host"),
      value: import_zod.z.string()
    }).strict(),
    import_zod.z.object({
      type: import_zod.z.literal("header"),
      key: import_zod.z.string(),
      value: import_zod.z.string().optional()
    }).strict(),
    import_zod.z.object({
      type: import_zod.z.literal("cookie"),
      key: import_zod.z.string(),
      value: import_zod.z.string().optional()
    }).strict(),
    import_zod.z.object({
      type: import_zod.z.literal("query"),
      key: import_zod.z.string(),
      value: import_zod.z.string().optional()
    }).strict()
  ])
).optional();
var vercelOutputConfigSchema = import_zod.z.object({
  version: import_zod.z.literal(3),
  routes: import_zod.z.array(
    import_zod.z.union([
      import_zod.z.object({
        src: import_zod.z.string(),
        dest: import_zod.z.string().optional(),
        headers: import_zod.z.record(import_zod.z.string()).optional(),
        methods: import_zod.z.array(import_zod.z.string()).optional(),
        status: import_zod.z.number().int().positive().optional(),
        continue: import_zod.z.boolean().optional(),
        check: import_zod.z.boolean().optional(),
        missing: HasOrMissing,
        has: HasOrMissing,
        locale: import_zod.z.object({
          redirect: import_zod.z.record(import_zod.z.string()).optional(),
          cookie: import_zod.z.string().optional()
        }).strict().optional(),
        middlewarePath: import_zod.z.string().optional()
      }).strict(),
      import_zod.z.object({
        handle: import_zod.z.union([
          import_zod.z.literal("rewrite"),
          import_zod.z.literal("filesystem"),
          import_zod.z.literal("resource"),
          import_zod.z.literal("miss"),
          import_zod.z.literal("hit"),
          import_zod.z.literal("error")
        ]),
        src: import_zod.z.string().optional(),
        dest: import_zod.z.string().optional(),
        status: import_zod.z.number().optional()
      }).strict()
    ])
  ).optional(),
  images: import_zod.z.object({
    sizes: import_zod.z.tuple([
      import_zod.z.number().int().positive(),
      import_zod.z.number().int().positive()
    ]),
    domains: import_zod.z.array(import_zod.z.string()).nonempty().optional(),
    minimumCacheTTL: import_zod.z.number().int().positive().optional(),
    formats: import_zod.z.union([import_zod.z.literal("image/avif"), import_zod.z.literal("image/webp")]).array().nonempty().optional(),
    dangerouslyAllowSVG: import_zod.z.boolean().optional(),
    contentSecurityPolicy: import_zod.z.string().optional()
  }).strict().optional(),
  wildcard: import_zod.z.array(
    import_zod.z.object({
      domain: import_zod.z.string(),
      value: import_zod.z.string()
    }).strict()
  ).optional(),
  overrides: import_zod.z.record(
    import_zod.z.object({
      path: import_zod.z.string().optional(),
      contentType: import_zod.z.string().optional()
    }).strict()
  ).optional(),
  cache: import_zod.z.array(import_zod.z.string()).optional()
}).strict();

// src/config.ts
var import_promises = __toESM(require("fs/promises"), 1);
var import_routing_utils = require("@vercel/routing-utils");
function reorderEnforce(arr) {
  return [
    ...arr.filter((r) => r.enforce === "pre"),
    ...arr.filter((r) => !r.enforce),
    ...arr.filter((r) => r.enforce === "post")
  ];
}
function getConfig(resolvedConfig, rewrites, overrides, headers) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  const _rewrites = [
    // User provided config always comes first
    ...((_a = resolvedConfig.vercel) == null ? void 0 : _a.rewrites) ?? [],
    ...rewrites ?? []
  ];
  const { routes, error } = (0, import_routing_utils.getTransformedRoutes)({
    cleanUrls: ((_b = resolvedConfig.vercel) == null ? void 0 : _b.cleanUrls) ?? true,
    trailingSlash: (_c = resolvedConfig.vercel) == null ? void 0 : _c.trailingSlash,
    rewrites: reorderEnforce(_rewrites),
    redirects: ((_d = resolvedConfig.vercel) == null ? void 0 : _d.redirects) ? reorderEnforce((_e = resolvedConfig.vercel) == null ? void 0 : _e.redirects) : void 0,
    headers
  });
  if (error) {
    throw error;
  }
  if (((_g = (_f = resolvedConfig.vercel) == null ? void 0 : _f.config) == null ? void 0 : _g.routes) && resolvedConfig.vercel.config.routes.length > 0 && !resolvedConfig.vercel.config.routes.every(
    (r) => "continue" in r && r.continue
  )) {
    console.warn(
      'Did you forget to add `"continue": true` to your routes? See https://vercel.com/docs/build-output-api/v3/configuration#source-route\nIf not, it is discouraged to use `vercel.config.routes` to override routes. Prefer using `vercel.rewrites` and `vercel.redirects`.'
    );
  }
  let userRoutes = [];
  let buildRoutes = [];
  if ((_i = (_h = resolvedConfig.vercel) == null ? void 0 : _h.config) == null ? void 0 : _i.routes) {
    const norm = (0, import_routing_utils.normalizeRoutes)(resolvedConfig.vercel.config.routes);
    if (norm.error) {
      throw norm.error;
    }
    userRoutes = norm.routes ?? [];
  }
  if (routes) {
    const norm = (0, import_routing_utils.normalizeRoutes)(routes);
    if (norm.error) {
      throw norm.error;
    }
    buildRoutes = norm.routes ?? [];
  }
  const cleanRoutes = (0, import_routing_utils.mergeRoutes)({
    userRoutes,
    builds: [
      {
        use: "@vercel/node",
        entrypoint: "index.js",
        routes: buildRoutes
      }
    ]
  });
  return vercelOutputConfigSchema.parse({
    version: 3,
    ...(_j = resolvedConfig.vercel) == null ? void 0 : _j.config,
    routes: cleanRoutes,
    overrides: {
      ...(_l = (_k = resolvedConfig.vercel) == null ? void 0 : _k.config) == null ? void 0 : _l.overrides,
      ...overrides
    }
  });
}
function getConfigDestination(resolvedConfig) {
  return import_path2.default.join(getOutput(resolvedConfig), "config.json");
}
async function writeConfig(resolvedConfig, rewrites, overrides, headers) {
  await import_promises.default.writeFile(
    getConfigDestination(resolvedConfig),
    JSON.stringify(
      getConfig(resolvedConfig, rewrites, overrides, headers),
      void 0,
      2
    ),
    "utf-8"
  );
}

// src/build.ts
var import_fast_glob = __toESM(require("fast-glob"), 1);
var import_path3 = __toESM(require("path"), 1);
var import_esbuild = require("esbuild");

// src/assert.ts
var import_libassert = require("@brillout/libassert");
var libName = "vite-plugin-vercel";
function assert(condition, errorMessage) {
  if (condition) {
    return;
  }
  const err = (0, import_libassert.newError)(`[${libName}][Wrong Usage] ${errorMessage}`, 2);
  throw err;
}

// src/schemas/config/vc-config.ts
var import_zod2 = require("zod");
var vercelOutputEdgeVcConfigSchema = import_zod2.z.object({
  runtime: import_zod2.z.literal("edge"),
  entrypoint: import_zod2.z.string(),
  envVarsInUse: import_zod2.z.array(import_zod2.z.string()).optional()
}).strict();
var vercelOutputServerlessVcConfigSchema = import_zod2.z.object({
  runtime: import_zod2.z.string(),
  handler: import_zod2.z.string(),
  memory: import_zod2.z.number().int().min(128).max(3008).optional(),
  maxDuration: import_zod2.z.number().int().positive().optional(),
  environment: import_zod2.z.record(import_zod2.z.string()).optional(),
  regions: import_zod2.z.array(import_zod2.z.string()).optional()
}).strict();
var vercelOutputServerlessNodeVcConfigSchema = vercelOutputServerlessVcConfigSchema.extend({
  launcherType: import_zod2.z.literal("Nodejs"),
  shouldAddHelpers: import_zod2.z.boolean().optional(),
  shouldAddSourcemapSupport: import_zod2.z.boolean().optional(),
  awsLambdaHandler: import_zod2.z.string().optional()
}).strict();
var vercelOutputVcConfigSchema = import_zod2.z.union([
  vercelOutputEdgeVcConfigSchema,
  vercelOutputServerlessVcConfigSchema,
  vercelOutputServerlessNodeVcConfigSchema
]);

// src/build.ts
var import_promises2 = __toESM(require("fs/promises"), 1);
var import_eval = __toESM(require("eval"), 1);

// src/schemas/exports.ts
var import_zod3 = require("zod");
var vercelEndpointExports = import_zod3.z.object({
  edge: import_zod3.z.boolean().optional(),
  headers: import_zod3.z.record(import_zod3.z.string()).optional(),
  isr: import_zod3.z.object({
    expiration: import_zod3.z.number().or(import_zod3.z.literal(false))
  }).optional()
});

// src/build.ts
var import_magicast = require("magicast");
var import_build_utils = require("@vercel/build-utils");
function getAdditionalEndpoints(resolvedConfig) {
  var _a;
  return (((_a = resolvedConfig.vercel) == null ? void 0 : _a.additionalEndpoints) ?? []).map((e) => ({
    ...e,
    addRoute: e.addRoute ?? true,
    // path.resolve removes the trailing slash if any
    destination: import_path3.default.posix.resolve("/", e.destination) + ".func"
  }));
}
function getEntries(resolvedConfig) {
  const apiEntries = import_fast_glob.default.sync(`${getRoot(resolvedConfig)}/api/**/*.*([a-zA-Z0-9])`).filter((filepath) => !import_path3.default.basename(filepath).startsWith("_"));
  if (apiEntries.length > 0) {
    console.warn(
      "@vercel/build is currently force building /api files itself, with no way to disable it. In order to avoid double compilation, you should temporarily rename /api to /_api while using this plugin. /_api functions are compiled under .vercel/output/functions/api/*.func as if they were in /api."
    );
  }
  const otherApiEntries = import_fast_glob.default.sync(`${getRoot(resolvedConfig)}/_api/**/*.*([a-zA-Z0-9])`).filter((filepath) => !import_path3.default.basename(filepath).startsWith("_"));
  return [...apiEntries, ...otherApiEntries].reduce((entryPoints, filePath) => {
    const outFilePath = pathRelativeTo(
      filePath,
      resolvedConfig,
      filePath.includes("/_api/") ? "_api" : "api"
    );
    const parsed = import_path3.default.posix.parse(outFilePath);
    entryPoints.push({
      source: filePath,
      destination: `api/${import_path3.default.posix.join(parsed.dir, parsed.name)}.func`,
      addRoute: true
    });
    return entryPoints;
  }, getAdditionalEndpoints(resolvedConfig));
}
var wasmPlugin = {
  name: "wasm",
  setup(build2) {
    build2.onResolve({ filter: /\.wasm/ }, (args) => {
      return {
        path: args.path.replace(/\.wasm\?module$/i, ".wasm"),
        external: true
      };
    });
  }
};
var vercelOgPlugin = (ctx) => {
  return {
    name: "vercel-og",
    setup(build2) {
      build2.onResolve({ filter: /@vercel\/og/ }, () => {
        ctx.found = true;
        return void 0;
      });
      build2.onLoad({ filter: /@vercel\/og/ }, (args) => {
        ctx.index = args.path;
        return void 0;
      });
    }
  };
};
var standardBuildOptions = {
  bundle: true,
  target: "es2020",
  format: "cjs",
  platform: "node",
  logLevel: "info",
  logOverride: {
    "ignored-bare-import": "verbose",
    "require-resolve-not-external": "verbose"
  },
  minify: true,
  plugins: [wasmPlugin]
};
async function buildFn(resolvedConfig, entry, buildOptions) {
  assert(
    entry.destination.length > 0,
    `Endpoint ${typeof entry.source === "string" ? entry.source : "-"} does not have build destination`
  );
  const outfile = import_path3.default.join(
    getOutput(resolvedConfig, "functions"),
    entry.destination,
    "index.js"
  );
  const options = Object.assign({}, standardBuildOptions, { outfile });
  if (buildOptions) {
    Object.assign(options, buildOptions);
  }
  if (!options.stdin) {
    if (typeof entry.source === "string") {
      options.entryPoints = [entry.source];
    } else {
      assert(
        typeof entry.source === "object",
        `\`{ source }\` must be a string or an object`
      );
      assert(
        typeof entry.source.contents === "string",
        `\`{ contents }\` must be a string`
      );
      options.stdin = entry.source;
    }
  }
  if (entry.edge) {
    options.conditions = [
      "edge-light",
      "browser",
      "module",
      "import",
      "require"
    ];
    options.format = "esm";
  }
  const ctx = { found: false, index: "" };
  options.plugins.push(vercelOgPlugin(ctx));
  const output = await (0, import_esbuild.build)(options);
  if (ctx.found && ctx.index) {
    const dir = (0, import_path3.dirname)(ctx.index);
    const externalFiles = await (0, import_fast_glob.default)(`${dir}/*.{ttf,wasm}`);
    for (const f of externalFiles) {
      await (0, import_promises2.copyFile)(
        f,
        import_path3.default.join(
          getOutput(resolvedConfig, "functions"),
          entry.destination,
          (0, import_path3.basename)(f)
        )
      );
    }
  }
  await writeVcConfig(resolvedConfig, entry.destination, Boolean(entry.edge));
  return output;
}
async function writeVcConfig(resolvedConfig, destination, edge) {
  var _a;
  const vcConfig = import_path3.default.join(
    getOutput(resolvedConfig, "functions"),
    destination,
    ".vc-config.json"
  );
  const nodeVersion = await (0, import_build_utils.getNodeVersion)(getOutput(resolvedConfig));
  await import_promises2.default.writeFile(
    vcConfig,
    JSON.stringify(
      vercelOutputVcConfigSchema.parse(
        edge ? {
          runtime: "edge",
          entrypoint: "index.js"
        } : {
          runtime: nodeVersion.runtime,
          handler: "index.js",
          maxDuration: (_a = resolvedConfig.vercel) == null ? void 0 : _a.defaultMaxDuration,
          launcherType: "Nodejs",
          shouldAddHelpers: true
        }
      ),
      void 0,
      2
    ),
    "utf-8"
  );
}
function getSourceAndDestination(destination) {
  if (destination.startsWith("api/")) {
    return import_path3.default.posix.resolve("/", destination);
  }
  return import_path3.default.posix.resolve("/", destination, ":match*");
}
async function removeDefaultExport(filepath) {
  const mod = await (0, import_magicast.loadFile)(filepath);
  try {
    delete mod.exports.default;
  } catch (_) {
  }
  return (0, import_magicast.generateCode)(mod).code;
}
async function extractExports(filepath) {
  var _a;
  const contents = await removeDefaultExport(filepath);
  const buildOptions = {
    ...standardBuildOptions,
    minify: false,
    write: false,
    legalComments: "none"
  };
  buildOptions.stdin = {
    sourcefile: filepath,
    contents,
    loader: filepath.endsWith(".ts") ? "ts" : filepath.endsWith(".tsx") ? "tsx" : filepath.endsWith(".js") ? "js" : filepath.endsWith(".jsx") ? "jsx" : "default",
    resolveDir: (0, import_path3.dirname)(filepath)
  };
  try {
    const output = await (0, import_esbuild.build)(buildOptions);
    const bundle = new TextDecoder().decode((_a = output.outputFiles[0]) == null ? void 0 : _a.contents);
    return vercelEndpointExports.parse((0, import_eval.default)(bundle, filepath, {}, true));
  } catch (e) {
    console.warn(`Warning: failed to read exports of '${filepath}'`, e);
  }
}
async function buildEndpoints(resolvedConfig) {
  const entries = getEntries(resolvedConfig);
  for (const entry of entries) {
    if (typeof entry.source === "string") {
      const exports = await extractExports(entry.source);
      if (exports) {
        if (entry.headers || exports.headers) {
          entry.headers = {
            ...exports.headers,
            ...entry.headers
          };
        }
        if (entry.edge !== void 0 && exports.edge !== void 0) {
          throw new Error(
            `edge configuration should be defined either in the endpoint itself or through Vite config, not both ('${entry.source}')`
          );
        }
        if (exports.edge !== void 0) {
          entry.edge = exports.edge;
        }
        if (entry.isr !== void 0 && exports.isr !== void 0) {
          throw new Error(
            `isr configuration should be defined either in the endpoint itself or through Vite config, not both ('${entry.source}')`
          );
        }
        if (exports.isr) {
          entry.isr = exports.isr;
        }
      }
    }
    await buildFn(resolvedConfig, entry);
  }
  const isrEntries = entries.filter((e) => e.isr).map(
    (e) => [
      e.destination.replace(/\.func$/, ""),
      { expiration: e.isr.expiration }
    ]
  );
  return {
    rewrites: entries.filter((e) => e.addRoute !== false).map((e) => e.destination.replace(/\.func$/, "")).map((destination) => ({
      source: getSourceAndDestination(destination),
      destination: getSourceAndDestination(destination)
    })),
    isr: Object.fromEntries(isrEntries),
    headers: entries.filter((e) => e.headers).map((e) => ({
      source: "/" + e.destination.replace(/\.func$/, ""),
      headers: Object.entries(e.headers).map(([key, value]) => ({
        key,
        value
      }))
    }))
  };
}

// src/prerender.ts
var import_path4 = __toESM(require("path"), 1);

// src/schemas/config/prerender-config.ts
var import_zod4 = require("zod");
var vercelOutputPrerenderConfigSchema = import_zod4.z.object({
  expiration: import_zod4.z.union([import_zod4.z.number().int().positive(), import_zod4.z.literal(false)]),
  group: import_zod4.z.number().int().optional(),
  bypassToken: import_zod4.z.string().optional(),
  fallback: import_zod4.z.string().optional(),
  allowQuery: import_zod4.z.array(import_zod4.z.string()).optional()
}).strict();

// src/prerender.ts
var import_promises3 = __toESM(require("fs/promises"), 1);
function execPrerender(resolvedConfig) {
  var _a;
  const prerender = (_a = resolvedConfig.vercel) == null ? void 0 : _a.prerender;
  if (prerender === false) {
    return;
  }
  return prerender == null ? void 0 : prerender(resolvedConfig);
}
var group = 1;
async function writePrerenderConfig(resolvedConfig, destination, isr) {
  const parsed = import_path4.default.parse(destination);
  const outfile = import_path4.default.join(
    getOutput(resolvedConfig, "functions"),
    parsed.dir,
    parsed.name + ".prerender-config.json"
  );
  await import_promises3.default.mkdir(
    import_path4.default.join(getOutput(resolvedConfig, "functions"), parsed.dir),
    { recursive: true }
  );
  await import_promises3.default.writeFile(
    outfile,
    JSON.stringify(
      vercelOutputPrerenderConfigSchema.parse({
        group: group++,
        ...isr
      }),
      void 0,
      2
    ),
    "utf-8"
  );
}
function getPrerenderSymlinkInfo(resolvedConfig, destination, target) {
  const parsed = import_path4.default.parse(destination);
  const targetParsed = import_path4.default.parse(target);
  return {
    target: import_path4.default.join(
      getOutput(resolvedConfig, "functions"),
      targetParsed.dir,
      targetParsed.name + ".func"
    ),
    link: import_path4.default.join(
      getOutput(resolvedConfig, "functions"),
      parsed.dir,
      parsed.name + ".func"
    )
  };
}
async function buildPrerenderConfigs(resolvedConfig, extractedIsr) {
  const isr = Object.assign(
    {},
    extractedIsr,
    await getIsrConfig(resolvedConfig)
  );
  const entries = Object.entries(isr);
  const rewrites = [];
  for (const [destination, { symlink, route, ...isr2 }] of entries) {
    await writePrerenderConfig(resolvedConfig, destination, isr2);
    if (symlink) {
      const info = getPrerenderSymlinkInfo(
        resolvedConfig,
        destination,
        symlink
      );
      await copyDir(info.target, info.link);
    }
    if (route) {
      rewrites.push({
        source: `(${route})`,
        destination: `${destination}/?__original_path=$1`
      });
    }
  }
  return rewrites;
}
async function copyDir(src, dest) {
  await import_promises3.default.mkdir(dest, { recursive: true });
  const entries = await import_promises3.default.readdir(src, { withFileTypes: true });
  for (const entry of entries) {
    const srcPath = import_path4.default.join(src, entry.name);
    const destPath = import_path4.default.join(dest, entry.name);
    entry.isDirectory() ? await copyDir(srcPath, destPath) : await import_promises3.default.copyFile(srcPath, destPath);
  }
}
async function getIsrConfig(resolvedConfig) {
  var _a;
  const isr = ((_a = resolvedConfig.vercel) == null ? void 0 : _a.isr) ?? {};
  if (typeof isr === "function") {
    return await isr();
  }
  return isr;
}

// src/index.ts
var import_path5 = __toESM(require("path"), 1);
function vercelPlugin() {
  let resolvedConfig;
  let vikeFound = false;
  return {
    apply: "build",
    name: "vite-plugin-vercel",
    enforce: "post",
    configResolved(config) {
      resolvedConfig = config;
      vikeFound = resolvedConfig.plugins.some(
        (p) => p.name.match("^vite-plugin-ssr:|^vike:")
      );
    },
    async writeBundle() {
      var _a;
      if (!((_a = resolvedConfig.build) == null ? void 0 : _a.ssr)) {
        await cleanOutputDirectory(resolvedConfig);
        if (vikeFound) {
          return;
        }
      }
      const overrides = await execPrerender(resolvedConfig);
      const userOverrides = await computeStaticHtmlOverrides(resolvedConfig);
      const { rewrites, isr, headers } = await buildEndpoints(resolvedConfig);
      rewrites.push(...await buildPrerenderConfigs(resolvedConfig, isr));
      await writeConfig(
        resolvedConfig,
        rewrites,
        {
          ...userOverrides,
          ...overrides
        },
        headers
      );
    }
  };
}
async function cleanOutputDirectory(resolvedConfig) {
  await import_promises4.default.rm(getOutput(resolvedConfig), {
    recursive: true,
    force: true
  });
  await import_promises4.default.mkdir(getOutput(resolvedConfig), { recursive: true });
}
async function computeStaticHtmlOverrides(resolvedConfig) {
  const staticAbsolutePath = getOutput(resolvedConfig, "static");
  const files = await getStaticHtmlFiles(staticAbsolutePath);
  const publicDir = getPublic(resolvedConfig);
  const publicFiles = await getStaticHtmlFiles(publicDir);
  files.push(
    ...publicFiles.map((f) => f.replace(publicDir, staticAbsolutePath))
  );
  return files.reduce((acc, curr) => {
    const relPath = import_path5.default.relative(staticAbsolutePath, curr);
    const parsed = import_path5.default.parse(relPath);
    const pathJoined = import_path5.default.join(parsed.dir, parsed.name);
    acc[relPath] = {
      path: pathJoined
    };
    return acc;
  }, {});
}
async function getStaticHtmlFiles(src) {
  try {
    await import_promises4.default.stat(src);
  } catch (e) {
    return [];
  }
  const entries = await import_promises4.default.readdir(src, { withFileTypes: true });
  const htmlFiles = [];
  for (const entry of entries) {
    const srcPath = import_path5.default.join(src, entry.name);
    entry.isDirectory() ? htmlFiles.push(...await getStaticHtmlFiles(srcPath)) : srcPath.endsWith(".html") ? htmlFiles.push(srcPath) : void 0;
  }
  return htmlFiles;
}
async function tryImportVpvv() {
  try {
    await import("vike/plugin");
    const vpvv = await import("@vite-plugin-vercel/vike");
    return vpvv.default();
  } catch (e) {
    try {
      await import("vite-plugin-ssr/plugin");
      const vpvv = await import("@vite-plugin-vercel/vike");
      return vpvv.default();
    } catch (e2) {
      return null;
    }
  }
}
function allPlugins(options = {}) {
  return [vercelPlugin(), options.smart !== false ? tryImportVpvv() : null];
}
